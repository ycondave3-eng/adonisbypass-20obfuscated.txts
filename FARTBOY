getgenv().Cider = {

	Main = {
		Intro = true,
		Sync = true,

		Keybinds = {
			["Aim Assist"] = "C",
			["Silent Aim"] = "C",
			["Trigger Bot Target"] = "C",
			["Trigger Bot Activate"] = "MouseButton1",
			["Speed"] = "T",
			["Jump Power"] = "Y",
			["Inventory Sorter"] = "F2",
			["Panic"] = "L",
			["Raid Awareness"] = "K",
		},

		Panic = {
			Enabled = false,
			["Disable Aim Assist"] = true,
			["Disable Silent Aim"] = true,
			["Disable Trigger Bot"] = true,
			["Disable Visuals"] = true,
			["Disable Player Modifications"] = true,
			["Disable Raid Awareness"] = true,
		},
	},

	TargetChecks = {
		Knocked = true,
		Grabbed = false,
		Wall = true,
		Forcefield = true,
	},

	SelfChecks = {
		Knocked = true,
		Grabbed = true,
		Forcefield = false,
	},

	UnlockConditions = {
		["Unlock on Target Knock"] = true,
		["Unlock on Self Knock"] = false,
	},

	SilentAimbot = {
		Enabled = true,
		["Target Mode"] = "Target",
		["Target Line"] = false,
		["Override Y Axis"] = "None",

		["Hit Target"] = {
			["Hit Part"] = "Closest Point",
		},

		FOV = {
			["FOV Type"] = "Circle",
			["Circle Value"] = 75,
			Box = {
				X = 45,
				Y = 45,
			},
			Visualize = false,
		},

		Prediction = {
			X = 0,
			Y = 0,
			Z = 0,
			Power = {
				Enabled = false,
				["Prediction Power"] = 1.042,
			},
		},

		["Anti Curve"] = {
			Enabled = false,
			Mode = "Angles",
			Angles = {
				["Max Angle"] = 12,
				["Distance Threshold"] = 100,
				["Debug Print"] = false,
			},
		},
	},

	AimAssist = {
		Enabled = true,
		Mode = "Camera",

		["Hit Target"] = {
			["Hit Part"] = "Closest Point",
			Prediction = {
				X = 0.002,
				Y = 0.002,
				Z = 0.002,
			},
		},

		["Camera Mode"] = {
			["Shift Locked"] = true,
			["Third Person"] = true,
			["First Person"] = true,
		},

		Smoothing = {
			["Smoothing Value"] = {
				X = 0.07,
				Y = 0.07,
				Z = 0.07,
				["Mouse Smoothing"] = {
					X = 0.17,
					Y = 0.17,
					Z = 0.17,
				},
			},
			Easing = {
				First = "Sine",
				Second = "Sine",
				["Easing Direction"] = "InOut",
			},
		},

		FOV = {
			["FOV Type"] = "Circle",
			["Circle Value"] = 75,
			Box = {
				X = 75,
				Y = 75,
			},
			Visualize = false,
		},
	},

	Triggerbot = {
		Enabled = true,
		["Shoot Mode"] = "Hitbox",
		["Target Mode"] = "Target",
		Mode = "Toggle",

		Timing = {
			Cooldown = 0.0,
		},

		Prediction = {
			X = 0,
			Y = 0,
			Z = 0,
		},

		FOV = {
			["FOV Type"] = "Circle",
			["Circle Value"] = 45,
			Box = {
				X = 75,
				Y = 75,
			},
			Visualize = false,
		},
	},

	RaidAwareness = {
		Enabled = true,
		["Max Render Distance"] = 250,

		Binds = {
			["Add Target"] = "J",
			["Remove Target"] = "P",
		},

		Box = {
			Enabled = true,
			["Box Color"] = Color3.fromRGB(255, 255, 255),
		},

		Name = {
			Enabled = true,
			Type = "Display",
			Color = Color3.fromRGB(255, 255, 255),
		},

		Health = {
			Enabled = true,
			Type = "Bar",
			["Missing Health Color"] = Color3.fromRGB(255, 0, 0),
			["High Health Color"] = Color3.fromRGB(0, 255, 0),
		},

		Lines = {
			Enabled = false,
			Type = "Top",
			Color = Color3.fromRGB(255, 255, 255),
		},
	},

	PlayerModification = {
		Movement = {
			Enabled = true,

			["Speed Modifications"] = {
				Enabled = true,
				Value = 5,
			},

			["Jump Modifications"] = {
				Enabled = true,
				Value = 2,
			},
		},

		["Weapon Modifications"] = {
			Enabled = true,

			["Double-Barrel SG"] = { Value = 0.2 },
			["TacticalShotgun"] = { Value = 0.2 },
			["Other Shotguns"] = { Value = 0.2 },
		},

		["Inventory Sorter"] = {
			Enabled = true,
			["Sort Food"] = true,
			Order = {
				"[Double-Barrel SG]",
				"[Revolver]",
				"[TacticalShotgun]",
				"[Knife]",
			},
		},
	},
}
--// Config
local Config = shared.cider

--// Services
local uis = game:GetService("UserInputService")
local rs = game:GetService("RunService")
local players = game:GetService("Players")
local workspace = game:GetService("Workspace")
local coreGui = game:GetService("CoreGui")
local vm = game:GetService("VirtualInputManager")

--// Player & Camera
local plr = players.LocalPlayer
local cam = workspace.CurrentCamera
local mouse = plr:GetMouse()

--// Keycodes
local keycodes = {
    ['A'] = Enum.KeyCode.A, ['B'] = Enum.KeyCode.B, ['C'] = Enum.KeyCode.C, ['D'] = Enum.KeyCode.D,
    ['E'] = Enum.KeyCode.E, ['F'] = Enum.KeyCode.F, ['G'] = Enum.KeyCode.G, ['H'] = Enum.KeyCode.H,
    ['I'] = Enum.KeyCode.I, ['J'] = Enum.KeyCode.J, ['K'] = Enum.KeyCode.K, ['L'] = Enum.KeyCode.L,
    ['M'] = Enum.KeyCode.M, ['N'] = Enum.KeyCode.N, ['O'] = Enum.KeyCode.O, ['P'] = Enum.KeyCode.P,
    ['Q'] = Enum.KeyCode.Q, ['R'] = Enum.KeyCode.R, ['S'] = Enum.KeyCode.S, ['T'] = Enum.KeyCode.T,
    ['U'] = Enum.KeyCode.U, ['V'] = Enum.KeyCode.V, ['W'] = Enum.KeyCode.W, ['X'] = Enum.KeyCode.X,
    ['Y'] = Enum.KeyCode.Y, ['Z'] = Enum.KeyCode.Z,
}

--// Body parts
local bodyParts = {
    "Head", "UpperTorso", "HumanoidRootPart", "LowerTorso",
    "LeftUpperArm", "RightUpperArm", "LeftLowerArm", "RightLowerArm",
    "LeftHand", "RightHand", "LeftUpperLeg", "RightUpperLeg",
    "LeftLowerLeg", "RightLowerLeg", "LeftFoot", "RightFoot"
}

--// Camera / Aimbot state
local cameraAimbotLocked = false
local cameraAimbotTarget = nil
local characterList = {}
local lastUpdate = 0
local fovVisualizer = nil
local fovLines = {}
local speedModActive = false

--// Utility functions
local function getKey(key)
    return keycodes[key:upper()] or Enum.KeyCode.Unknown
end

local function isInFirstPerson()
    if not plr.Character or not plr.Character:FindFirstChild("Head") then return false end
    local distance = (cam.CFrame.Position - plr.Character.Head.Position).Magnitude
    return distance < 2
end

local function isValidCameraMode()
    local isFP = isInFirstPerson()
    local thirdPersonEnabled = Config['Camera Aimbot']['Camera Mode']['Third Person']
    local firstPersonEnabled = Config['Camera Aimbot']['Camera Mode']['First Person']

    if isFP then
        return firstPersonEnabled
    else
        return thirdPersonEnabled
    end
end

local function hasForcefield(char)
    if not Config['Universal Checks']['Forcefield'] then return false end
    for _, child in ipairs(char:GetChildren()) do
        if child:IsA("ForceField") then return true end
    end
    return false
end

local function validChar(char)
    if not char or not char.Parent then return false end
    if hasForcefield(char) then return false end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    return char:FindFirstChild("HumanoidRootPart") ~= nil
end

local function wallCheck(targetPart)
    if not Config['Universal Checks']['Wall'] then return true end
    local origin = cam.CFrame.Position
    local direction = (targetPart.Position - origin)

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = { plr.Character }
    rayParams.IgnoreWater = true

    local result = workspace:Raycast(origin, direction, rayParams)
    if not result then return true end
    return targetPart.Parent:IsAncestorOf(result.Instance)
end

--// Closest point function
local function getClosestPoint(part, useCameraDirection)
    if not part or not part:IsA("BasePart") then return part.Position end

    local cf = part.CFrame
    local size = part.Size
    local rayOrigin, rayDirection

    if useCameraDirection then
        rayOrigin = cam.CFrame.Position
        rayDirection = cam.CFrame.LookVector
    else
        local mousePos = uis:GetMouseLocation()
        local mouseRay = cam:ScreenPointToRay(mousePos.X, mousePos.Y)
        rayOrigin = mouseRay.Origin
        rayDirection = mouseRay.Direction
    end

    if size.Magnitude < 2 then
        lastBestPos = part.Position      -- ⚠️ lastBestPos not declared
        lastPointCheck = now             -- ⚠️ now not declared
        return part.Position
    end

    local bestPos = part.Position
    local closestDist = math.huge
    local halfSize = size * 0.5

    for x = -1, 1, 0.2 do
        for y = -1, 1, 0.2 do
            for z = -1, 1, 0.2 do
                if math.abs(x) > 0.99 or math.abs(y) > 0.99 or math.abs(z) > 0.99 then
                    local localPos = Vector3.new(x * halfSize.X, y * halfSize.Y, z * halfSize.Z)
                    local worldPos = cf:PointToWorldSpace(localPos)
                    local pointToRay = worldPos - rayOrigin
                    local projectionLength = pointToRay:Dot(rayDirection)
                    local closestPointOnRay = rayOrigin + rayDirection * projectionLength
                    local distanceToRay = (worldPos - closestPointOnRay).Magnitude
                    if distanceToRay < closestDist then
                        closestDist = distanceToRay
                        bestPos = worldPos
                    end
                end
            end
        end
    end

    return bestPos
end

--// Prediction
local function applyPrediction(part, position)
    if not part then return position end
    local velocity = part.AssemblyLinearVelocity or Vector3.new(0,0,0)
    local prediction = Config['Camera Aimbot']['Prediction']

    return position + Vector3.new(
        velocity.X * prediction.X,
        velocity.Y * prediction.Y,
        velocity.Z * prediction.Z
    )
end

--// Get all valid characters
local function getAllPlayers()
    local chars = {}
    for _, player in ipairs(players:GetPlayers()) do
        if player ~= plr and player.Character and validChar(player.Character) then
            table.insert(chars, player.Character)
        end
    end

    local botsFolder = workspace:FindFirstChild('Bots')
    if botsFolder then
        for _, bot in ipairs(botsFolder:GetChildren()) do
            if bot:FindFirstChild('Humanoid') and bot:FindFirstChild('HumanoidRootPart') and validChar(bot) then
                table.insert(chars, bot)
            end
        end
    end
    return chars
end

local function getCharacters()
    local now = tick()
    if now - lastUpdate > 0.5 then
        characterList = getAllPlayers()
        lastUpdate = now
    end
    return characterList
end

--// Find target logic
local function findTarget(char, useCameraDirection)
    if not char then return nil, nil end
    local hitTarget = Config['Camera Aimbot']['Hit Target']['Style']
    local bestPart, bestPos, bestDist = nil, nil, math.huge
    local rayOrigin, rayDirection

    if useCameraDirection then
        rayOrigin = cam.CFrame.Position
        rayDirection = cam.CFrame.LookVector
    else
        local mousePos = uis:GetMouseLocation()
        local mouseRay = cam:ScreenPointToRay(mousePos.X, mousePos.Y)
        rayOrigin = mouseRay.Origin
        rayDirection = mouseRay.Direction
    end

    if hitTarget ~= "Closest Point" and hitTarget ~= "Closest Part" then
        local part = char:FindFirstChild(hitTarget)
        if part and part:IsA("BasePart") and wallCheck(part) then
            if hitTarget == "Closest Point" then
                bestPos = getClosestPoint(part, useCameraDirection)
            else
                bestPos = part.Position
            end
            return part, bestPos
        end
        return nil, nil
    end

    if hitTarget == "Closest Point" then
        local mousePos = uis:GetMouseLocation()
        local closestScreenDist = math.huge
        for _, partName in ipairs(bodyParts) do
            local part = char:FindFirstChild(partName)
            if part and part:IsA("BasePart") and wallCheck(part) then
                local screenPos, onScreen = cam:WorldToViewportPoint(part.Position)
                if onScreen and screenPos.Z > 0 then
                    local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    if screenDist < closestScreenDist then
                        closestScreenDist = screenDist
                        bestPart = part
                    end
                end
            end
        end
        if bestPart then
            bestPos = getClosestPoint(bestPart, useCameraDirection)
        end
    else
        for _, partName in ipairs(bodyParts) do
            local part = char:FindFirstChild(partName)
            if part and part:IsA("BasePart") and wallCheck(part) then
                local pos = part.Position
                local pointToRay = pos - rayOrigin
                local projectionLength = pointToRay:Dot(rayDirection)
                local closestPointOnRay = rayOrigin + rayDirection * projectionLength
                local distanceToRay = (pos - closestPointOnRay).Magnitude
                if distanceToRay < bestDist then
                    bestDist = distanceToRay
                    bestPart = part
                    bestPos = pos
                end
            end
        end
    end

    return bestPart, bestPos
end
getgenv().UsedAdonisBypass = true 

local oldfunction; 
oldfunction = hookfunction(debug.info, function(...)
	local args = {...}
	if (args[1] == 2 and args[2] == "f") then
		return nil
	else
		return oldfunction(...);
	end
end);

repeat task.wait(0.1) until game:IsLoaded()

for Index, Data in next, getgc() do
	pcall(function()
		local info = debug.getinfo(Data)
		local up = debug.getconstants(Data)
		if typeof(Data) == "function" and info.name == "Immutable" then
			hookfunction(Data, function()
				return nil
			end)
		elseif typeof(Data) == "function" and table.find(up, "MethodError") and table.find(up, "ServerError") and table.find(up, "ReadError") then
			hookfunction(v, function()
				return nil
			end)
		elseif typeof(Data) == "function" and table.find(up, "Disconnected from server") then
			hookfunction(v, function()
				return nil
			end)
		elseif typeof(Data) == "function" and table.find(up, "fakePlayer") then
			hookfunction(v, function()
				return nil
			end)
		elseif typeof(Data) == "function" and table.find(up, "Tampering with Client [read rt0001]") and table.find(up, "ReadError") and table.find(up, "Potentially dangerous index") then
			hookfunction(v, function()
				return nil
			end)
		end
	end)
end

local LocalPlayer = game.Players.LocalPlayer
local oldhmmi
local oldhmmnc
oldhmmi = hookmetamethod(game, "__index", function(self, method)
	if self == LocalPlayer and method:lower() == "kick" then
		return function()
			--print("lol dumb adonis")
		end
	end
	return oldhmmi(self, method)
end)
oldhmmnc = hookmetamethod(game, "__namecall", function(self, ...)
	if self == LocalPlayer and getnamecallmethod():lower() == "kick" then
		return
	end
	return oldhmmnc(self, ...)
end)

function findRemoteEventWithFunction(parent)
	-- Iterate through all the children of the parent
	for _, child in ipairs(parent:GetChildren()) do
		-- Check if the child is a RemoteEvent
		if child:IsA("RemoteEvent") then
			-- Iterate through all the children of the RemoteEvent
			for _, grandchild in ipairs(child:GetChildren()) do
				-- Check if the grandchild is a RemoteFunction named "__function"
				if grandchild:IsA("RemoteFunction") and grandchild.Name == "__FUNCTION" then
					-- Return the RemoteEvent if found
					return child
				end
			end
		end
	end
	-- Return nil if no such RemoteEvent is found
	return nil
end

local rf = findRemoteEventWithFunction(game:GetService("ReplicatedStorage"))
local ofunc
ofunc = hookfunction(rf.FireServer, function (...)
	local args = {...}
	if args[2] == "BadMemes" or table.find(args,"kick") then
		--print("blocked adonis rcall")
		return nil
	end
	--print(...)
	return ofunc(...)
end)
local foundfunc = nil
local foundtable1 = nil
local foundtable2 = nil
while getgenv().UsedAdonisBypass do
    if foundfunc == nil then
        for Index, Data in next, getgc(false) do
            pcall(function()
                local info
                if type(Data) == "function" then
                    info = debug.getinfo(Data)
                end
                if foundfunc == nil and type(Data) == "function" and info.name == "Send" and islclosure(Data) then
                    foundfunc = Data
                end
            end)
        end
        for Index, Data in next, getgc(true) do
            pcall(function()
                if foundfunc ~= nil and type(Data) == "table" and Data.CheckClient and Data.Returnables and Data.Send == foundfunc then
                    --print("Remote: " .. tostring(Data))
                    foundtable1 = Data
                end
                if type(Data) == "table" and Data.Remote and Data.DepsName then
                    --print("Client: " .. tostring(Data))
                    foundtable2 = Data
                end
            end)
        end
    else
        foundfunc("ClientCheck", {Sent = foundtable1.Sent or 0, Received = foundtable1.Received}, foundtable2.DepsName)
    end
    task.wait(10)
end
